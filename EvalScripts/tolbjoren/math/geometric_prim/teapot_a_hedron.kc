// ref: http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/AV0405/DONAVANIK/bezier.html
//      http://paulbourke.net/geometry/bezier/
// data: ftp://ftp.funet.fi/pub/sci/graphics/packages/objects/teaset.tar.Z
struct vec{x,y,z,w;};

enum {NUM_PATCHES = 32}
static patches[NUM_PATCHES*16] = 
{
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
4,17,18,19,8,20,21,22,12,23,24,25,16,26,27,28,
19,29,30,31,22,32,33,34,25,35,36,37,28,38,39,40,
31,41,42,1,34,43,44,5,37,45,46,9,40,47,48,13,
13,14,15,16,49,50,51,52,53,54,55,56,57,58,59,60,
16,26,27,28,52,61,62,63,56,64,65,66,60,67,68,69,
28,38,39,40,63,70,71,72,66,73,74,75,69,76,77,78,
40,47,48,13,72,79,80,49,75,81,82,53,78,83,84,57,
57,58,59,60,85,86,87,88,89,90,91,92,93,94,95,96,
60,67,68,69,88,97,98,99,92,100,101,102,96,103,104,105,
69,76,77,78,99,106,107,108,102,109,110,111,105,112,113,114,
78,83,84,57,108,115,116,85,111,117,118,89,114,119,120,93,
121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,
124,137,138,121,128,139,140,125,132,141,142,129,136,143,144,133,
133,134,135,136,145,146,147,148,149,150,151,152,69,153,154,155,
136,143,144,133,148,156,157,145,152,158,159,149,155,160,161,69,
162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,
165,178,179,162,169,180,181,166,173,182,183,170,177,184,185,174,
174,175,176,177,186,187,188,189,190,191,192,193,194,195,196,197,
177,184,185,174,189,198,199,186,193,200,201,190,197,202,203,194,
204,204,204,204,207,208,209,210,211,211,211,211,212,213,214,215,
204,204,204,204,210,217,218,219,211,211,211,211,215,220,221,222,
204,204,204,204,219,224,225,226,211,211,211,211,222,227,228,229,
204,204,204,204,226,230,231,207,211,211,211,211,229,232,233,212,
212,213,214,215,234,235,236,237,238,239,240,241,242,243,244,245,
215,220,221,222,237,246,247,248,241,249,250,251,245,252,253,254,
222,227,228,229,248,255,256,257,251,258,259,260,254,261,262,263,
229,232,233,212,257,264,265,234,260,266,267,238,263,268,269,242,
270,270,270,270,279,280,281,282,275,276,277,278,271,272,273,274,
270,270,270,270,282,289,290,291,278,286,287,288,274,283,284,285,
270,270,270,270,291,298,299,300,288,295,296,297,285,292,293,294,
270,270,270,270,300,305,306,279,297,303,304,275,294,301,302,271
};

static pts[3*306] = 
{
1.4,0.0,2.4,
1.4,-0.784,2.4,
0.784,-1.4,2.4,
0.0,-1.4,2.4,
1.3375,0.0,2.53125,
1.3375,-0.749,2.53125,
0.749,-1.3375,2.53125,
0.0,-1.3375,2.53125,
1.4375,0.0,2.53125,
1.4375,-0.805,2.53125,
0.805,-1.4375,2.53125,
0.0,-1.4375,2.53125,
1.5,0.0,2.4,
1.5,-0.84,2.4,
0.84,-1.5,2.4,
0.0,-1.5,2.4,
-0.784,-1.4,2.4,
-1.4,-0.784,2.4,
-1.4,0.0,2.4,
-0.749,-1.3375,2.53125,
-1.3375,-0.749,2.53125,
-1.3375,0.0,2.53125,
-0.805,-1.4375,2.53125,
-1.4375,-0.805,2.53125,
-1.4375,0.0,2.53125,
-0.84,-1.5,2.4,
-1.5,-0.84,2.4,
-1.5,0.0,2.4,
-1.4,0.784,2.4,
-0.784,1.4,2.4,
0.0,1.4,2.4,
-1.3375,0.749,2.53125,
-0.749,1.3375,2.53125,
0.0,1.3375,2.53125,
-1.4375,0.805,2.53125,
-0.805,1.4375,2.53125,
0.0,1.4375,2.53125,
-1.5,0.84,2.4,
-0.84,1.5,2.4,
0.0,1.5,2.4,
0.784,1.4,2.4,
1.4,0.784,2.4,
0.749,1.3375,2.53125,
1.3375,0.749,2.53125,
0.805,1.4375,2.53125,
1.4375,0.805,2.53125,
0.84,1.5,2.4,
1.5,0.84,2.4,
1.75,0.0,1.875,
1.75,-0.98,1.875,
0.98,-1.75,1.875,
0.0,-1.75,1.875,
2.0,0.0,1.35,
2.0,-1.12,1.35,
1.12,-2.0,1.35,
0.0,-2.0,1.35,
2.0,0.0,0.9,
2.0,-1.12,0.9,
1.12,-2.0,0.9,
0.0,-2.0,0.9,
-0.98,-1.75,1.875,
-1.75,-0.98,1.875,
-1.75,0.0,1.875,
-1.12,-2.0,1.35,
-2.0,-1.12,1.35,
-2.0,0.0,1.35,
-1.12,-2.0,0.9,
-2.0,-1.12,0.9,
-2.0,0.0,0.9,
-1.75,0.98,1.875,
-0.98,1.75,1.875,
0.0,1.75,1.875,
-2.0,1.12,1.35,
-1.12,2.0,1.35,
0.0,2.0,1.35,
-2.0,1.12,0.9,
-1.12,2.0,0.9,
0.0,2.0,0.9,
0.98,1.75,1.875,
1.75,0.98,1.875,
1.12,2.0,1.35,
2.0,1.12,1.35,
1.12,2.0,0.9,
2.0,1.12,0.9,
2.0,0.0,0.45,
2.0,-1.12,0.45,
1.12,-2.0,0.45,
0.0,-2.0,0.45,
1.5,0.0,0.225,
1.5,-0.84,0.225,
0.84,-1.5,0.225,
0.0,-1.5,0.225,
1.5,0.0,0.15,
1.5,-0.84,0.15,
0.84,-1.5,0.15,
0.0,-1.5,0.15,
-1.12,-2.0,0.45,
-2.0,-1.12,0.45,
-2.0,0.0,0.45,
-0.84,-1.5,0.225,
-1.5,-0.84,0.225,
-1.5,0.0,0.225,
-0.84,-1.5,0.15,
-1.5,-0.84,0.15,
-1.5,0.0,0.15,
-2.0,1.12,0.45,
-1.12,2.0,0.45,
0.0,2.0,0.45,
-1.5,0.84,0.225,
-0.84,1.5,0.225,
0.0,1.5,0.225,
-1.5,0.84,0.15,
-0.84,1.5,0.15,
0.0,1.5,0.15,
1.12,2.0,0.45,
2.0,1.12,0.45,
0.84,1.5,0.225,
1.5,0.84,0.225,
0.84,1.5,0.15,
1.5,0.84,0.15,
-1.6,0.0,2.025,
-1.6,-0.3,2.025,
-1.5,-0.3,2.25,
-1.5,0.0,2.25,
-2.3,0.0,2.025,
-2.3,-0.3,2.025,
-2.5,-0.3,2.25,
-2.5,0.0,2.25,
-2.7,0.0,2.025,
-2.7,-0.3,2.025,
-3.0,-0.3,2.25,
-3.0,0.0,2.25,
-2.7,0.0,1.8,
-2.7,-0.3,1.8,
-3.0,-0.3,1.8,
-3.0,0.0,1.8,
-1.5,0.3,2.25,
-1.6,0.3,2.025,
-2.5,0.3,2.25,
-2.3,0.3,2.025,
-3.0,0.3,2.25,
-2.7,0.3,2.025,
-3.0,0.3,1.8,
-2.7,0.3,1.8,
-2.7,0.0,1.575,
-2.7,-0.3,1.575,
-3.0,-0.3,1.35,
-3.0,0.0,1.35,
-2.5,0.0,1.125,
-2.5,-0.3,1.125,
-2.65,-0.3,0.9375,
-2.65,0.0,0.9375,
-2.0,-0.3,0.9,
-1.9,-0.3,0.6,
-1.9,0.0,0.6,
-3.0,0.3,1.35,
-2.7,0.3,1.575,
-2.65,0.3,0.9375,
-2.5,0.3,1.125,
-1.9,0.3,0.6,
-2.0,0.3,0.9,
1.7,0.0,1.425,
1.7,-0.66,1.425,
1.7,-0.66,0.6,
1.7,0.0,0.6,
2.6,0.0,1.425,
2.6,-0.66,1.425,
3.1,-0.66,0.825,
3.1,0.0,0.825,
2.3,0.0,2.1,
2.3,-0.25,2.1,
2.4,-0.25,2.025,
2.4,0.0,2.025,
2.7,0.0,2.4,
2.7,-0.25,2.4,
3.3,-0.25,2.4,
3.3,0.0,2.4,
1.7,0.66,0.6,
1.7,0.66,1.425,
3.1,0.66,0.825,
2.6,0.66,1.425,
2.4,0.25,2.025,
2.3,0.25,2.1,
3.3,0.25,2.4,
2.7,0.25,2.4,
2.8,0.0,2.475,
2.8,-0.25,2.475,
3.525,-0.25,2.49375,
3.525,0.0,2.49375,
2.9,0.0,2.475,
2.9,-0.15,2.475,
3.45,-0.15,2.5125,
3.45,0.0,2.5125,
2.8,0.0,2.4,
2.8,-0.15,2.4,
3.2,-0.15,2.4,
3.2,0.0,2.4,
3.525,0.25,2.49375,
2.8,0.25,2.475,
3.45,0.15,2.5125,
2.9,0.15,2.475,
3.2,0.15,2.4,
2.8,0.15,2.4,
0.0,0.0,3.15,
0.0,-0.002,3.15,
0.002,0.0,3.15,
0.8,0.0,3.15,
0.8,-0.45,3.15,
0.45,-0.8,3.15,
0.0,-0.8,3.15,
0.0,0.0,2.85,
0.2,0.0,2.7,
0.2,-0.112,2.7,
0.112,-0.2,2.7,
0.0,-0.2,2.7,
-0.002,0.0,3.15,
-0.45,-0.8,3.15,
-0.8,-0.45,3.15,
-0.8,0.0,3.15,
-0.112,-0.2,2.7,
-0.2,-0.112,2.7,
-0.2,0.0,2.7,
0.0,0.002,3.15,
-0.8,0.45,3.15,
-0.45,0.8,3.15,
0.0,0.8,3.15,
-0.2,0.112,2.7,
-0.112,0.2,2.7,
0.0,0.2,2.7,
0.45,0.8,3.15,
0.8,0.45,3.15,
0.112,0.2,2.7,
0.2,0.112,2.7,
0.4,0.0,2.55,
0.4,-0.224,2.55,
0.224,-0.4,2.55,
0.0,-0.4,2.55,
1.3,0.0,2.55,
1.3,-0.728,2.55,
0.728,-1.3,2.55,
0.0,-1.3,2.55,
1.3,0.0,2.4,
1.3,-0.728,2.4,
0.728,-1.3,2.4,
0.0,-1.3,2.4,
-0.224,-0.4,2.55,
-0.4,-0.224,2.55,
-0.4,0.0,2.55,
-0.728,-1.3,2.55,
-1.3,-0.728,2.55,
-1.3,0.0,2.55,
-0.728,-1.3,2.4,
-1.3,-0.728,2.4,
-1.3,0.0,2.4,
-0.4,0.224,2.55,
-0.224,0.4,2.55,
0.0,0.4,2.55,
-1.3,0.728,2.55,
-0.728,1.3,2.55,
0.0,1.3,2.55,
-1.3,0.728,2.4,
-0.728,1.3,2.4,
0.0,1.3,2.4,
0.224,0.4,2.55,
0.4,0.224,2.55,
0.728,1.3,2.55,
1.3,0.728,2.55,
0.728,1.3,2.4,
1.3,0.728,2.4,
0.0,0.0,0.0,
1.5,0.0,0.15,
1.5,0.84,0.15,
0.84,1.5,0.15,
0.0,1.5,0.15,
1.5,0.0,0.075,
1.5,0.84,0.075,
0.84,1.5,0.075,
0.0,1.5,0.075,
1.425,0.0,0.0,
1.425,0.798,0.0,
0.798,1.425,0.0,
0.0,1.425,0.0,
-0.84,1.5,0.15,
-1.5,0.84,0.15,
-1.5,0.0,0.15,
-0.84,1.5,0.075,
-1.5,0.84,0.075,
-1.5,0.0,0.075,
-0.798,1.425,0.0,
-1.425,0.798,0.0,
-1.425,0.0,0.0,
-1.5,-0.84,0.15,
-0.84,-1.5,0.15,
0.0,-1.5,0.15,
-1.5,-0.84,0.075,
-0.84,-1.5,0.075,
0.0,-1.5,0.075,
-1.425,-0.798,0.0,
-0.798,-1.425,0.0,
0.0,-1.425,0.0,
0.84,-1.5,0.15,
1.5,-0.84,0.15,
0.84,-1.5,0.075,
1.5,-0.84,0.075,
0.798,-1.425,0.0,
1.425,-0.798,0.0
};
static vec scratch_pts[4][4];
static geomatx[4*4];
static geomaty[4*4];
static geomatz[4*4];

static time;   

#define SHOW_CONTROLPOINTS
#define SHOW_NORMALS
()
{
   cls(0); clz(1e32); glcullface(GL_FRONT); time = klock(0);
   
   ang =mousx/xres*2*PI;
   r = -5;
   camx = sin(ang)*r;
   camz = cos(ang)*r;
   setcam(camx, 0, camz,ang,0);
   
if (bstatus <= 0 ) 
{
   for(i=0; i<NUM_PATCHES; i++)
   {
      makePatch(i,0);
   }
   
   //makePatch(mousx/xres*NUM_PATCHES);
}
else{
  

  for(i=0; i<16; i++){
     makePatch( (floor(8*time)+i) % NUM_PATCHES, 0 );
  }
}


}

makePatch(patchIdx, showCtlOnly)
{
      glBegin(GL_POINTS);
      for(i=0; i<4; i++) {
      for(j=0; j<4; j++) {
        ptIdx = patches[16*patchIdx+(4*i+j) ]-1; 
        x = pts[3*ptIdx+0]; 
        y = pts[3*ptIdx+1]; 
        z = pts[3*ptIdx+2];

        //#define DEFORM
        #ifdef DEFORM
        s=i+j;
        //if (s!=0 && s!=3 && s!=6)
        {
          x += .5*noise(x,10*time);
          y += .5*noise(x,y,10*time);
          z += .5*noise(x,y,z+10*time);
        }
        #endif
        
        #ifdef DEFORM_ROTATE
        ang = .25*sin(y+time); //mousy/yres*2*PI;
        ca = cos(ang); sa = sin(ang);
        tx=x; ty=y; tz=z;
        x = ca*tx - sa*tz;
        z = sa*tx + ca*tz;
        #endif
                

        vecset(scratch_pts[i][j],x,2-z,y);
        geomatx[4*i+j]=x;
        geomaty[4*i+j]=2-z;
        geomatz[4*i+j]=y;
        #ifdef SHOW_CONTROLPOINTS
          setcol(255,0,0); glVertex(x,2-z,y);
        #endif
      } }
      
#ifdef SHOW_CONTROLPOINTS
      setcol(0,0,255);
      moveto( scratch_pts[0][0] ); lineto( scratch_pts[3][0] );
      moveto( scratch_pts[3][0] ); lineto( scratch_pts[3][3] );
      moveto( scratch_pts[3][3] ); lineto( scratch_pts[0][3] );
      moveto( scratch_pts[0][3] ); lineto( scratch_pts[0][0] );
#endif
if (showCtlOnly ) return;
         
      setcol(255,255,0);
      
      vec patchCorners[4];
      vec patchNormals[4];
      vec texCoords[4];
      res=8;
      
      du=1/res; dv=1/res;
      for(i=0; i<res; i++) {
      for(j=0; j<res; j++) {
         
         u0 = i*du;
         u1 = (i+1)*du;
         
         v0 = j*dv;
         v1 = (j+1)*dv;
         
         calcPatch(u0,v0,patchCorners[0]);
         calcPatch(u1,v0,patchCorners[1]);
         calcPatch(u1,v1,patchCorners[2]);
         calcPatch(u0,v1,patchCorners[3]);
         
         calcPatchNormal(u0,v0,patchNormals[0]);
         calcPatchNormal(u1,v0,patchNormals[1]);
         calcPatchNormal(u1,v1,patchNormals[2]);
         calcPatchNormal(u0,v1,patchNormals[3]);
         
         vecset(texCoords[0], 1-u0, v0, 0);
         vecset(texCoords[1], 1-u1, v0, 0);
         vecset(texCoords[2], 1-u1, v1, 0);
         vecset(texCoords[3], 1-u0, v1, 0);
         

         vec ldir = {.1, -.3, .0, 0};                  
         normalize(ldir);
         
         //setcol(u1*255, v1*255, 0);
         
         glBegin(GL_QUADS); //glBegin(GL_LINE_LOOP);
         for(idx=0; idx<4; idx++){
           ndotl = vecdot( patchNormals[idx], ldir);
           setcol( 127+127*ndotl, 127+127*ndotl, 127+127*ndotl );
           glTexCoord(texCoords[idx]);
           glVertex(patchCorners[idx]);
         }
         glEnd();
         
         #ifdef WIRE
         setcol(255, 255, 0);
         glBegin(GL_LINE_LOOP);
         for(idx=0; idx<4; idx++){
           glVertex(patchCorners[idx]);
         }
         glEnd();
         #endif
         
         #ifdef SHOW_NORMALS
         setcol(0, 255, 0);
         len = .1;
         glBegin(GL_LINES);
         for(idx=0; idx<4; idx++){
           glVertex(patchCorners[idx]);
           nx = patchCorners[idx].x + len*patchNormals[idx].x;
           ny = patchCorners[idx].y + len*patchNormals[idx].y;
           nz = patchCorners[idx].z + len*patchNormals[idx].z;
           glVertex(nx,ny,nz);
         }
         glEnd();
         #endif
         
      } }
}

vecset(vec v,x,y,z){v.x=x; v.y=y; v.z=z;}
vecset(vec a, vec b){a.x=b.x; a.y=b.y; a.z=b.z; a.w=b.w;}
moveto(vec v){moveto(v.x,v.y,v.z);}
lineto(vec v){lineto(v.x,v.y,v.z);}
glvertex(vec v){glvertex(v.x,v.y,v.z);}
gltexcoord(vec v){gltexcoord(v.x,v.y);}

calcPatch(u,v,vec outPt)
{
   static mbasis[4*4] = {
      -1, 3,-3, 1,
       3,-6, 3, 0,
      -3, 3, 0, 0,
       1, 0, 0, 0
   };
   
   outPt.x = 0;
   outPt.y = 0;
   outPt.z = 0;

#define FASTWAY
#ifdef FASTWAY
   vec uvec = {u^3, u^2, u, 1};
   vec vvec = {v^3, v^2, v, 1};
   
   vec tmp;
   
   vecset(tmp,uvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomatx, tmp  );
   mat4vec4( mbasis, tmp );
   outPt.x = vecdot(tmp, vvec);
   
   vecset(tmp,uvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomaty, tmp  );
   mat4vec4( mbasis, tmp );
   outPt.y = vecdot(tmp, vvec);
   
   vecset(tmp,uvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomatz, tmp  );
   mat4vec4( mbasis, tmp );
   outPt.z = vecdot(tmp, vvec);
#else
   
   
   for(i=0; i<4; i++)
   {
     wu = bernstein(3,i,u+0.01); //+0.01 is a hack :(


     for(j=0; j<4; j++)
     {
        wv = bernstein(3,j,v+0.01);
        w = wu*wv;
        
        outPt.x += w*scratch_pts[j][i].x;
        outPt.y += w*scratch_pts[j][i].y;
        outPt.z += w*scratch_pts[j][i].z;
     }
   }
#endif   
   
}

calcPatchNormal(u,v,vec outPt)
{
   static mbasis[4*4] = {
      -1, 3,-3, 1,
       3,-6, 3, 0,
      -3, 3, 0, 0,
       1, 0, 0, 0
   };
   
   vec uvec = {u^3, u^2, u, 1};
   vec vvec = {v^3, v^2, v, 1};
   
   vec dtuvec = {3*u^2, 2*u, 1, 0};
   vec dtvvec = {3*v^2, 2*v, 1, 0};
   
   vec delU, delV;
   vec tmp;

// u part   
   vecset(tmp,dtuvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomatx, tmp  );
   mat4vec4( mbasis, tmp );
   delU.x = vecdot(tmp, vvec);
   
   vecset(tmp,dtuvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomaty, tmp  );
   mat4vec4( mbasis, tmp );
   delU.y = vecdot(tmp, vvec);
   
   vecset(tmp,dtuvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomatz, tmp  );
   mat4vec4( mbasis, tmp );
   delU.z = vecdot(tmp, vvec);
   
//// v part

   vecset(tmp,uvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomatx, tmp  );
   mat4vec4( mbasis, tmp );
   delV.x = vecdot(tmp, dtvvec);
   
   vecset(tmp,uvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomaty, tmp  );
   mat4vec4( mbasis, tmp );
   delV.y = vecdot(tmp, dtvvec);
   
   vecset(tmp,uvec);
   
   mat4vec4( mbasis, tmp );
   mat4vec4( geomatz, tmp  );
   mat4vec4( mbasis, tmp );
   delV.z = vecdot(tmp, dtvvec);
   
   vecCross(outPt, delU, delV);
   normalize(outPt);
}

length( vec v )
{
   return sqrt( vecdot(v,v) );
}
normalize( vec v )
{
   len = length(v);
   if ( len )
   {
      v.x /= len; v.y /= len; v.z /= len;
   }
}
vecCross( vec out, vec a, vec b)
{
   out.x = a.y*b.z - a.z*b.y;
   out.y = a.z*b.x - a.x*b.z;
   out.z = a.x*b.y - a.y*b.x;
}

vecdot(vec a, vec b) {
   return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w;
}

Mat4Vec4(mat[4*4], vec v )
{
   x = mat[0] * v.x + mat[1] * v.y + mat[2] * v.z + mat[3]*v.w;
   y = mat[4] * v.x + mat[5] * v.y + mat[6] * v.z + mat[7]*v.w;
   z = mat[8] * v.x + mat[9] * v.y + mat[10] * v.z + mat[11]*v.w;
   w = mat[12] * v.x + mat[13] * v.y + mat[14] * v.z + mat[15]*v.w;
   v.x=x; v.y=y; v.z=z; v.w=w;
}

Matrix_Mult(a1[4*4],a2[4*4],a3[4*4])
{
   i=0;
   j=0;
   k=0;
   for(i=0; i<4; i++)
      for(j=0; j<4; j++)
      a3[4*i+j] = 0.0;
   
   for(i=0; i<4; i++)
      for(j=0; j<4; j++)
         for(k=0; k<4; k++)
            a3[4*i+j] += a1[4*i+k] * a2[4*k+j];

}

bernstein(n,i,u)
{
  num = fact(n);
  den = fact(i)*fact(n-i);
  binom = num / den;
  return binom * u^i * (1-u)^(n-i); //readable :)
  //return binom * pow(u,i) * pow( (1-u), (n-i));
}